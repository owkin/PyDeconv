{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyDeconv","text":"<p>Python implementation of deconvolution methods for bulk RNA-seq data.</p> <ul> <li> <p>Quickstart</p> </li> <li> <p>How to install</p> </li> <li> <p>Signature registry</p> </li> <li> <p>Model registry</p> </li> <li> <p>Python API</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributor-guide","title":"Contributor Guide","text":"<p>Thank you for your interest in improving this project!</p> <p>We welcome contributions from anyone from Owkin in the form of suggestions, bug reports, pull requests, and feedback. This document will guide you through the process of contributing to this project.</p> <p>Here is a list of important resources for contributing:</p> <ul> <li>Source Code</li> <li>Issue Tracker</li> <li>Documentation</li> </ul>"},{"location":"contributing/#how-to-report-a-bug","title":"How to report a bug","text":"<p>Report bugs on the Issue Tracker.</p> <p>When filing an issue, make sure to answer these questions:</p> <ul> <li>Which Python version are you using?</li> <li>Which version of this project are you using?</li> <li>What did you do?</li> <li>What did you expect to see?</li> <li>What did you see instead?</li> </ul> <p>The best way to get your bug fixed is to provide a test case, and/or steps to reproduce the issue.</p>"},{"location":"contributing/#how-to-request-a-feature","title":"How to request a feature","text":"<p>Request features on the Issue Tracker.</p>"},{"location":"contributing/#how-to-set-up-your-development-environment","title":"How to set up your development environment","text":"<p>You need uv. (Yes that's it, you don't need to install anything else)</p>"},{"location":"contributing/#set-up-the-environment","title":"Set up the environment","text":"<p>Retrieve the project from the repository and navigate to the root directory of the project.</p> <pre><code>git clone git@github.com:owkin/PyDeconv.git\ncd PyDeconv\n</code></pre> <p>To install all required dependencies and the pinned version of Python, run:</p> <pre><code>uv sync\n</code></pre> <p>It will install the python dependencies needed for the project.</p>"},{"location":"contributing/#quality-checks","title":"Quality checks","text":"<p>If you have installed the pre-commit hooks, they will be run automatically before each commit.</p> <p>You can also run them manually with:</p> <pre><code># All checks used in the pre-commit hooks\nmake checks\n\n# Format the code\nmake fmt\n\n# Run the linter\nmake lint\n</code></pre>"},{"location":"contributing/#test-suite","title":"Test suite","text":"<p>Unit tests are located in the tests directory, and are written using the pytest testing framework.</p> <p>To run the test suite, run:</p> <pre><code>make tests\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>The documentation is written using [mkdocs-material].</p> <p>To serve the documentation locally, run:</p> <pre><code>make docs-serve\n</code></pre> <p>To build the documentation, run:</p> <pre><code>make docs-build\n</code></pre>"},{"location":"contributing/#start-working-on-a-new-feature","title":"Start working on a new feature","text":"<p>It is recommended to open an issue before starting work on anything. This will allow a chance to talk it over with the owners and validate your approach.</p> <p>We follow the GitHub flow branching model.</p> <p>To start working on a new feature, create a new branch from the <code>main</code> branch:</p> <pre><code>$ git checkout main\n$ git pull\n$ git checkout -b my-new-feature\n</code></pre> <p>You can also create a new branch directly from the GitHub interface.</p>"},{"location":"contributing/#how-to-submit-changes","title":"How to submit changes","text":"<p>Once you are done working on your feature, push your branch to the remote repository and open a Pull Request.</p> <p>We will review your changes and merge them into the <code>main</code> branch if everything looks good.</p> <p>Your pull request should include: - a clear description of the changes you made - an update of the documentation (if needed) - a link to the issue you are fixing (if any) - tests for the new code (if applicable)</p> <p>Feel free to submit early drafts of your pull request if you want to get feedback on your work in progress. We can always help iterate on your changes.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>The goal of this project is to have a robust python implementation of deconvolution methods for bulk RNA-seq data.</p>"},{"location":"quickstart/#concepts","title":"Concepts","text":"<ul> <li>Introduction to deconvolution</li> </ul>"},{"location":"quickstart/#1-load-an-already-registered-signature-matrix","title":"1. Load an already registered signature matrix","text":"<pre><code>from pydeconv.signature_matrix.registry import sig_matrix_laughney_lung_cancer, sig_matrix_laughney_lung_cancer\nsignature_matrix = sig_matrix_laughney_lung_cancer()\n</code></pre> <p>Checkout here for more description of other registered signature matrix.</p>"},{"location":"quickstart/#2-load-a-custom-signature-matrix","title":"2. Load a custom signature matrix","text":"<pre><code>from pydeconv import SignatureMatrix\nsignature_matrix = SignatureMatrix.load(\"path/to/signature_matrix.csv\") #index: gene names, column: cell types\n</code></pre> <p>Note</p> <p>For the moment only <code>.csv</code> format is supported. You can add any kwargs arguments from <code>pd.read_csv</code> after the path.</p>"},{"location":"quickstart/#3-predict","title":"3. Predict","text":"<pre><code>from pydeconv.model import Tape, Scaden\n\nadata = AnnData(\"path/to/adata.h5ad\") # index: sample_id, columns: gene_names\nadata.layers[\"relative_counts\"] = ...\n\nsolver = Scaden()\ncell_prop = solver.transform(adata, layer=\"relative_counts\", ratio=True)\n</code></pre> <p>Note</p> <p>The model will check that you have the corresponding gene names in your input data.</p>"},{"location":"quickstart/#4-predict-signature-based-method","title":"4. Predict (signature based method)","text":"<pre><code>from pydeconv.model import OLS, NNLS, DWLS\n\nsignature_matrix = ...\nadata = AnnData(\"path/to/adata.h5ad\")\nadata.layers[\"relative_counts\"] = ...\n\nsolver = DWLS(signature_matrix)\ncell_prop = solver.transform(adata, layer=\"relative_counts\", ratio=True)\n</code></pre>"},{"location":"api/","title":"Overview","text":"<p>API reference for development of deconvolution methods for bulk RNA-seq data.</p>"},{"location":"api/model/model/","title":"Model","text":""},{"location":"api/model/model/#pydeconv.model.DWLS","title":"<code>DWLS</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>class DWLS(SignatureBasedModel):\n    def __init__(self, signature_matrix: SignatureMatrix, solver_method: Literal[\"ols\", \"nnls\", \"svr\"] = \"nnls\"):\n        \"\"\"Dumpened Weighted Least Squares (DWLS) model for deconvolution.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        solver_method : Literal[ols, nnls, svr], optional\n            solver method to use, by default \"nnls\"\n\n        Raises\n        ------\n\n        \"\"\"\n        super().__init__(name=\"DWLS\", signature_matrix=signature_matrix)\n        self._baseline_solver = SOLVER_METHODS.get(solver_method)\n        if self._baseline_solver is None:\n            raise ValueError(f\"Solver {solver_method} not found\")\n\n    def transform(\n        self,\n        adata: AnnData,\n        layer: str = \"relative_counts\",\n        ratio: bool = False,\n        max_iter: int = 1000,\n        tol: float = 1e-2,\n        dampened: Union[list, Literal[\"auto\"], None] = \"auto\",\n        parallel: bool = False,\n    ):\n        \"\"\"Fit the DWLS model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Input anndata object.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            If True return a proportion of celltype instead raw values, by default False\n        max_iter : int, optional\n            Maximum number of iterations, by default 1000\n        tol : float, optional\n            Tolerance, by default 1\n        dampened : Union[list, Literal[auto], None], optional\n            Dampened values, by default \"auto\"\n        parallel : bool, optional\n            If True, use parallel computation, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n        if layer is None:\n            layer = self.default_layer\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_wls(\n            adata,\n            self._signature_matrix,\n            layer=layer,\n            max_iter=max_iter,\n            tol=tol,\n            dampened=dampened,\n            solver_func=self._baseline_solver,\n            parallel=parallel,\n        )\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.DWLS.__init__","title":"<code>__init__(signature_matrix, solver_method='nnls')</code>","text":"<p>Dumpened Weighted Least Squares (DWLS) model for deconvolution.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required <code>solver_method</code> <code>Literal[ols, nnls, svr]</code> <p>solver method to use, by default \"nnls\"</p> <code>'nnls'</code> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix, solver_method: Literal[\"ols\", \"nnls\", \"svr\"] = \"nnls\"):\n    \"\"\"Dumpened Weighted Least Squares (DWLS) model for deconvolution.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    solver_method : Literal[ols, nnls, svr], optional\n        solver method to use, by default \"nnls\"\n\n    Raises\n    ------\n\n    \"\"\"\n    super().__init__(name=\"DWLS\", signature_matrix=signature_matrix)\n    self._baseline_solver = SOLVER_METHODS.get(solver_method)\n    if self._baseline_solver is None:\n        raise ValueError(f\"Solver {solver_method} not found\")\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.DWLS.transform","title":"<code>transform(adata, layer='relative_counts', ratio=False, max_iter=1000, tol=0.01, dampened='auto', parallel=False)</code>","text":"<p>Fit the DWLS model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Input anndata object.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>If True return a proportion of celltype instead raw values, by default False</p> <code>False</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations, by default 1000</p> <code>1000</code> <code>tol</code> <code>float</code> <p>Tolerance, by default 1</p> <code>0.01</code> <code>dampened</code> <code>Union[list, Literal[auto], None]</code> <p>Dampened values, by default \"auto\"</p> <code>'auto'</code> <code>parallel</code> <code>bool</code> <p>If True, use parallel computation, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>def transform(\n    self,\n    adata: AnnData,\n    layer: str = \"relative_counts\",\n    ratio: bool = False,\n    max_iter: int = 1000,\n    tol: float = 1e-2,\n    dampened: Union[list, Literal[\"auto\"], None] = \"auto\",\n    parallel: bool = False,\n):\n    \"\"\"Fit the DWLS model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Input anndata object.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        If True return a proportion of celltype instead raw values, by default False\n    max_iter : int, optional\n        Maximum number of iterations, by default 1000\n    tol : float, optional\n        Tolerance, by default 1\n    dampened : Union[list, Literal[auto], None], optional\n        Dampened values, by default \"auto\"\n    parallel : bool, optional\n        If True, use parallel computation, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n    if layer is None:\n        layer = self.default_layer\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_wls(\n        adata,\n        self._signature_matrix,\n        layer=layer,\n        max_iter=max_iter,\n        tol=tol,\n        dampened=dampened,\n        solver_func=self._baseline_solver,\n        parallel=parallel,\n    )\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.MixupVI","title":"<code>MixupVI</code>","text":"<p>               Bases: <code>NeuralNetworkModel</code></p> Source code in <code>src/pydeconv/model/mixupvi.py</code> <pre><code>class MixupVI(NeuralNetworkModel):\n    model_registry: dict[str, Callable] = {\n        \"cti_1st_level_granularity\": partial(mixupvi_module_cti, granularity=\"1st_granularity\"),\n        \"cti_2nd_level_granularity\": partial(mixupvi_module_cti, granularity=\"2nd_granularity\"),\n    }\n    signature_registry: dict[str, Callable] = {\n        \"cti_1st_level_granularity\": signature_mixupvi_latent_space_1st_granularity,\n        \"cti_2nd_level_granularity\": signature_mixupvi_latent_space_2nd_granularity,\n    }\n\n    def __init__(\n        self, weights_version: str = \"cti_1st_level_granularity\", preprocessing: Optional[BasePreprocessing] = None\n    ):\n        \"\"\"MixupVI model for deconvolution.\"\"\"\n        super().__init__(name=\"MixupVI\", weights_version=weights_version)\n        self.preprocessing = preprocessing\n        self.signature_latent_space = self.signature_registry[weights_version]()\n\n    def transform(self, adata: AnnData, layer: str = \"raw_counts\", ratio=False):\n        \"\"\"Fit the Scaden model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        if self.preprocessing is not None:\n            adata_preprocessed = self.preprocessing(adata, layer, list_ordered_genes=self.params[\"input\"][\"gene_names\"])\n        else:\n            adata_preprocessed = adata\n        values = solver_mixupvi_module(self.module, self.signature_latent_space, adata_preprocessed, layer)\n\n        values = self.format_output(\n            values,\n            columns=self.list_cell_types,\n            index=adata.obs.index,\n            ratio=ratio,\n            only_positive=False,\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.MixupVI.__init__","title":"<code>__init__(weights_version='cti_1st_level_granularity', preprocessing=None)</code>","text":"<p>MixupVI model for deconvolution.</p> Source code in <code>src/pydeconv/model/mixupvi.py</code> <pre><code>def __init__(\n    self, weights_version: str = \"cti_1st_level_granularity\", preprocessing: Optional[BasePreprocessing] = None\n):\n    \"\"\"MixupVI model for deconvolution.\"\"\"\n    super().__init__(name=\"MixupVI\", weights_version=weights_version)\n    self.preprocessing = preprocessing\n    self.signature_latent_space = self.signature_registry[weights_version]()\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.MixupVI.transform","title":"<code>transform(adata, layer='raw_counts', ratio=False)</code>","text":"<p>Fit the Scaden model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'raw_counts'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/mixupvi.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"raw_counts\", ratio=False):\n    \"\"\"Fit the Scaden model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    if self.preprocessing is not None:\n        adata_preprocessed = self.preprocessing(adata, layer, list_ordered_genes=self.params[\"input\"][\"gene_names\"])\n    else:\n        adata_preprocessed = adata\n    values = solver_mixupvi_module(self.module, self.signature_latent_space, adata_preprocessed, layer)\n\n    values = self.format_output(\n        values,\n        columns=self.list_cell_types,\n        index=adata.obs.index,\n        ratio=ratio,\n        only_positive=False,\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.NNLS","title":"<code>NNLS</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> <p>Non-Negative Least Squares (NNLS) model for deconvolution.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the model.</p> <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> <p>Methods:</p> Name Description <code>transform</code> <p>Fit the NNLS model to the data and return the deconvolution values.</p> Source code in <code>src/pydeconv/model/nnls.py</code> <pre><code>class NNLS(SignatureBasedModel):\n    \"\"\"Non-Negative Least Squares (NNLS) model for deconvolution.\n    Attributes\n    ----------\n    name : str\n        Name of the model.\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n\n    Methods\n    -------\n    transform(adata, layer, ratio=False)\n        Fit the NNLS model to the data and return the deconvolution values.\n    \"\"\"\n\n    def __init__(self, signature_matrix: SignatureMatrix):\n        \"\"\"\n        Initialize the NNLS model.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        \"\"\"\n        super().__init__(name=\"NNLS\", signature_matrix=signature_matrix)\n\n    def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=False) -&gt; pd.DataFrame:\n        \"\"\"Fit the NNLS model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_nnls(adata, self._signature_matrix, layer)\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.NNLS.__init__","title":"<code>__init__(signature_matrix)</code>","text":"<p>Initialize the NNLS model.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required Source code in <code>src/pydeconv/model/nnls.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix):\n    \"\"\"\n    Initialize the NNLS model.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    \"\"\"\n    super().__init__(name=\"NNLS\", signature_matrix=signature_matrix)\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.NNLS.transform","title":"<code>transform(adata, layer='relative_counts', ratio=False)</code>","text":"<p>Fit the NNLS model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/nnls.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=False) -&gt; pd.DataFrame:\n    \"\"\"Fit the NNLS model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_nnls(adata, self._signature_matrix, layer)\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.NuSVR","title":"<code>NuSVR</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> Source code in <code>src/pydeconv/model/svr.py</code> <pre><code>class NuSVR(SignatureBasedModel):\n    def __init__(self, signature_matrix: SignatureMatrix, norm=True, scale=False):\n        \"\"\"Support Vector Regression (SVR) model for deconvolution. NuSVR is similar to SVR but with a parameter to\n        control the number of support vectors.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        norm : bool, optional\n            if True, normalize the data, by default True\n        scale : bool, optional\n            if True, scale the data, by default False\n        \"\"\"\n        super().__init__(name=\"NuSVR\", signature_matrix=signature_matrix)\n        self.norm = norm\n        self.scale = scale\n\n    def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=False):\n        \"\"\"Fit the NuSVR model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Input anndata object.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            If True return a proportion of celltype instead raw values, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n        if layer is None:\n            layer = self.default_layer\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_nusvr(adata, self._signature_matrix, layer, norm=self.norm, scale=self.scale)\n\n        values = self.format_output(\n            values,\n            columns=self._signature_matrix.list_cell_types,\n            index=adata.obs.index,\n            ratio=ratio,\n            only_positive=True,\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.NuSVR.__init__","title":"<code>__init__(signature_matrix, norm=True, scale=False)</code>","text":"<p>Support Vector Regression (SVR) model for deconvolution. NuSVR is similar to SVR but with a parameter to control the number of support vectors.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required <code>norm</code> <code>bool</code> <p>if True, normalize the data, by default True</p> <code>True</code> <code>scale</code> <code>bool</code> <p>if True, scale the data, by default False</p> <code>False</code> Source code in <code>src/pydeconv/model/svr.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix, norm=True, scale=False):\n    \"\"\"Support Vector Regression (SVR) model for deconvolution. NuSVR is similar to SVR but with a parameter to\n    control the number of support vectors.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    norm : bool, optional\n        if True, normalize the data, by default True\n    scale : bool, optional\n        if True, scale the data, by default False\n    \"\"\"\n    super().__init__(name=\"NuSVR\", signature_matrix=signature_matrix)\n    self.norm = norm\n    self.scale = scale\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.NuSVR.transform","title":"<code>transform(adata, layer='relative_counts', ratio=False)</code>","text":"<p>Fit the NuSVR model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Input anndata object.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>If True return a proportion of celltype instead raw values, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/svr.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=False):\n    \"\"\"Fit the NuSVR model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Input anndata object.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        If True return a proportion of celltype instead raw values, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n    if layer is None:\n        layer = self.default_layer\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_nusvr(adata, self._signature_matrix, layer, norm=self.norm, scale=self.scale)\n\n    values = self.format_output(\n        values,\n        columns=self._signature_matrix.list_cell_types,\n        index=adata.obs.index,\n        ratio=ratio,\n        only_positive=True,\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.OLS","title":"<code>OLS</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> <p>Ordinary Least Squares (OLS) model for deconvolution.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the model.</p> <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> <p>Methods:</p> Name Description <code>transform</code> <p>Fit the OLS model to the data and return the deconvolution values.</p> Source code in <code>src/pydeconv/model/ols.py</code> <pre><code>class OLS(SignatureBasedModel):\n    \"\"\"Ordinary Least Squares (OLS) model for deconvolution.\n\n    Attributes\n    ----------\n    name : str\n        Name of the model.\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n\n    Methods\n    -------\n\n    transform(adata, layer, ratio=True)\n        Fit the OLS model to the data and return the deconvolution values.\n    \"\"\"\n\n    def __init__(self, signature_matrix: SignatureMatrix):\n        \"\"\"Initialize the OLS model.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        \"\"\"\n        super().__init__(name=\"OLS\", signature_matrix=signature_matrix)\n\n    def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=True):\n        \"\"\"Fit the OLS model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default True\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n        if layer is None:\n            layer = self.default_layer\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_ols(adata, self._signature_matrix, layer)\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.OLS.__init__","title":"<code>__init__(signature_matrix)</code>","text":"<p>Initialize the OLS model.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required Source code in <code>src/pydeconv/model/ols.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix):\n    \"\"\"Initialize the OLS model.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    \"\"\"\n    super().__init__(name=\"OLS\", signature_matrix=signature_matrix)\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.OLS.transform","title":"<code>transform(adata, layer='relative_counts', ratio=True)</code>","text":"<p>Fit the OLS model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/ols.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=True):\n    \"\"\"Fit the OLS model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default True\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n    if layer is None:\n        layer = self.default_layer\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_ols(adata, self._signature_matrix, layer)\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.RLR","title":"<code>RLR</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> <p>Robust Linear Regression (RLR) model for deconvolution.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the model.</p> <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> <p>Methods:</p> Name Description <code>transform</code> <p>Fit the RLR model to the data and return the deconvolution values.</p> Source code in <code>src/pydeconv/model/rlr.py</code> <pre><code>class RLR(SignatureBasedModel):\n    \"\"\"Robust Linear Regression (RLR) model for deconvolution.\n\n    Attributes\n    ----------\n    name : str\n        Name of the model.\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n\n    Methods\n    -------\n\n    transform(adata, layer, ratio=True)\n        Fit the RLR model to the data and return the deconvolution values.\n    \"\"\"\n\n    def __init__(self, signature_matrix: SignatureMatrix):\n        \"\"\"Initialize the RLR model.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        \"\"\"\n        super().__init__(name=\"RLR\", signature_matrix=signature_matrix)\n\n    def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=True):\n        \"\"\"Fit the RLR model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default True\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_rlr(adata, self._signature_matrix, layer)\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.RLR.__init__","title":"<code>__init__(signature_matrix)</code>","text":"<p>Initialize the RLR model.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required Source code in <code>src/pydeconv/model/rlr.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix):\n    \"\"\"Initialize the RLR model.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    \"\"\"\n    super().__init__(name=\"RLR\", signature_matrix=signature_matrix)\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.RLR.transform","title":"<code>transform(adata, layer='relative_counts', ratio=True)</code>","text":"<p>Fit the RLR model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/rlr.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=True):\n    \"\"\"Fit the RLR model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default True\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_rlr(adata, self._signature_matrix, layer)\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.SVR","title":"<code>SVR</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> Source code in <code>src/pydeconv/model/svr.py</code> <pre><code>class SVR(SignatureBasedModel):\n    def __init__(self, signature_matrix: SignatureMatrix):\n        \"\"\"Support Vector Regression (SVR) model for deconvolution.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        \"\"\"\n        super().__init__(name=\"SVR\", signature_matrix=signature_matrix)\n\n    def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=False):\n        \"\"\"Fit the SVR model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Input anndata object.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            If True return a proportion of celltype instead raw values, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n        if layer is None:\n            layer = self.default_layer\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_svr(adata, self._signature_matrix, layer)\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.SVR.__init__","title":"<code>__init__(signature_matrix)</code>","text":"<p>Support Vector Regression (SVR) model for deconvolution.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required Source code in <code>src/pydeconv/model/svr.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix):\n    \"\"\"Support Vector Regression (SVR) model for deconvolution.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    \"\"\"\n    super().__init__(name=\"SVR\", signature_matrix=signature_matrix)\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.SVR.transform","title":"<code>transform(adata, layer='relative_counts', ratio=False)</code>","text":"<p>Fit the SVR model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Input anndata object.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>If True return a proportion of celltype instead raw values, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/svr.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"relative_counts\", ratio=False):\n    \"\"\"Fit the SVR model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Input anndata object.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        If True return a proportion of celltype instead raw values, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n    if layer is None:\n        layer = self.default_layer\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_svr(adata, self._signature_matrix, layer)\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.Scaden","title":"<code>Scaden</code>","text":"<p>               Bases: <code>NeuralNetworkModel</code></p> Source code in <code>src/pydeconv/model/scaden.py</code> <pre><code>class Scaden(NeuralNetworkModel):\n    model_registry: dict[str, Callable] = {\n        \"cti_1st_level_granularity\": partial(scaden_module_cti, granularity=\"1st_granularity\"),\n        \"cti_2nd_level_granularity\": partial(scaden_module_cti, granularity=\"2nd_granularity\"),\n    }\n\n    def __init__(self, weights_version: str = \"cti_1st_level_granularity\"):\n        \"\"\"Scaden model for deconvolution.\"\"\"\n        super().__init__(name=\"Scaden\", weights_version=weights_version)\n        self.preprocessing = PreprocessingScaden()\n\n    def transform(self, adata: AnnData, layer: str = \"counts_sum\", ratio=False):\n        \"\"\"Fit the Scaden model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        adata_preprocessed = self.preprocessing(adata, layer, list_ordered_genes=self.params[\"input\"][\"gene_names\"])\n        values = solver_torch_module(self.module, adata_preprocessed, layer)\n\n        values = self.format_output(\n            values,\n            columns=self.list_cell_types,\n            index=adata.obs.index,\n            ratio=ratio,\n            only_positive=False,\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.Scaden.__init__","title":"<code>__init__(weights_version='cti_1st_level_granularity')</code>","text":"<p>Scaden model for deconvolution.</p> Source code in <code>src/pydeconv/model/scaden.py</code> <pre><code>def __init__(self, weights_version: str = \"cti_1st_level_granularity\"):\n    \"\"\"Scaden model for deconvolution.\"\"\"\n    super().__init__(name=\"Scaden\", weights_version=weights_version)\n    self.preprocessing = PreprocessingScaden()\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.Scaden.transform","title":"<code>transform(adata, layer='counts_sum', ratio=False)</code>","text":"<p>Fit the Scaden model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'counts_sum'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/scaden.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"counts_sum\", ratio=False):\n    \"\"\"Fit the Scaden model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    adata_preprocessed = self.preprocessing(adata, layer, list_ordered_genes=self.params[\"input\"][\"gene_names\"])\n    values = solver_torch_module(self.module, adata_preprocessed, layer)\n\n    values = self.format_output(\n        values,\n        columns=self.list_cell_types,\n        index=adata.obs.index,\n        ratio=ratio,\n        only_positive=False,\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.Tape","title":"<code>Tape</code>","text":"<p>               Bases: <code>NeuralNetworkModel</code></p> <p>Tape model for deconvolution.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the model.</p> <p>Methods:</p> Name Description <code>transform</code> <p>Fit the Tape model to the data and return the deconvolution values.</p> Source code in <code>src/pydeconv/model/tape.py</code> <pre><code>class Tape(NeuralNetworkModel):\n    \"\"\"Tape model for deconvolution.\n\n    Attributes\n    ----------\n    name : str\n        Name of the model.\n\n    Methods\n    -------\n    transform(adata, layer, ratio=False)\n        Fit the Tape model to the data and return the deconvolution values.\n    \"\"\"\n\n    model_registry: dict[str, Callable] = {\n        \"cti_1st_level_granularity\": partial(tape_module_cti, granularity=\"1st_granularity\"),\n        \"cti_2nd_level_granularity\": partial(tape_module_cti, granularity=\"2nd_granularity\"),\n    }\n\n    def __init__(self, weights_version: str = \"cti_1st_level_granularity\", adaptative=True):\n        \"\"\"\n\n        Parameters\n        ----------\n        adaptative : bool, optional\n            _description_, by default True\n        \"\"\"\n        super().__init__(name=\"TAPE\", weights_version=weights_version, adaptative=adaptative)\n        self.preprocessing = PreprocessingTape()\n\n    def transform(self, adata: AnnData, layer: str = \"counts_sum\", ratio=False):\n        \"\"\"Fit the Tape model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default False\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        adata_preprocessed = self.preprocessing(adata, layer, list_ordered_genes=self.params[\"input\"][\"gene_names\"])\n        values = solver_torch_module(self.module, adata_preprocessed, layer)\n\n        values = self.format_output(\n            values,\n            columns=self.list_cell_types,\n            index=adata.obs.index,\n            ratio=ratio,\n            only_positive=True,\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.Tape.__init__","title":"<code>__init__(weights_version='cti_1st_level_granularity', adaptative=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>adaptative</code> <code>bool</code> <p>description, by default True</p> <code>True</code> Source code in <code>src/pydeconv/model/tape.py</code> <pre><code>def __init__(self, weights_version: str = \"cti_1st_level_granularity\", adaptative=True):\n    \"\"\"\n\n    Parameters\n    ----------\n    adaptative : bool, optional\n        _description_, by default True\n    \"\"\"\n    super().__init__(name=\"TAPE\", weights_version=weights_version, adaptative=adaptative)\n    self.preprocessing = PreprocessingTape()\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.Tape.transform","title":"<code>transform(adata, layer='counts_sum', ratio=False)</code>","text":"<p>Fit the Tape model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'counts_sum'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/tape.py</code> <pre><code>def transform(self, adata: AnnData, layer: str = \"counts_sum\", ratio=False):\n    \"\"\"Fit the Tape model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default False\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    adata_preprocessed = self.preprocessing(adata, layer, list_ordered_genes=self.params[\"input\"][\"gene_names\"])\n    values = solver_torch_module(self.module, adata_preprocessed, layer)\n\n    values = self.format_output(\n        values,\n        columns=self.list_cell_types,\n        index=adata.obs.index,\n        ratio=ratio,\n        only_positive=True,\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.WLS","title":"<code>WLS</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>class WLS(SignatureBasedModel):\n    def __init__(self, signature_matrix: SignatureMatrix, solver_method: Literal[\"ols\", \"nnls\", \"svr\"] = \"nnls\"):\n        \"\"\"Weighted Least Squares (WLS) model for deconvolution.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n        solver_method : Literal[ols;, nnls, svr], optional\n\n\n        Raises\n        ------\n        ValueError\n            Raised when solver_method is not found.\n        \"\"\"\n        super().__init__(name=f\"wls_{solver_method}\", signature_matrix=signature_matrix)\n        self._baseline_solver = SOLVER_METHODS.get(solver_method)\n        if self._baseline_solver is None:\n            raise ValueError(f\"Solver {solver_method} not found\")\n\n    def transform(\n        self,\n        adata: AnnData,\n        layer: str = \"relative_counts\",\n        ratio: bool = False,\n        max_iter: int = 1000,\n        tol: float = 1e-3,\n    ):\n        \"\"\"Fit the WLS model to the data and return the deconvolution values.\n\n        Parameters\n        ----------\n        adata : AnnData\n            Anndata object containing the data.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            Transform raw output into cell proportions, by default False\n        max_iter : int, optional\n            Maximum number of iterations, by default 1000\n        tol : float, optional\n            Tolerance, by default 1e-3\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_wls(adata, self._signature_matrix, layer=layer, max_iter=max_iter, tol=tol, dampened=None)\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.WLS.__init__","title":"<code>__init__(signature_matrix, solver_method='nnls')</code>","text":"<p>Weighted Least Squares (WLS) model for deconvolution.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required <code>solver_method</code> <code>Literal[ols;, nnls, svr]</code> <code>'nnls'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised when solver_method is not found.</p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix, solver_method: Literal[\"ols\", \"nnls\", \"svr\"] = \"nnls\"):\n    \"\"\"Weighted Least Squares (WLS) model for deconvolution.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n    solver_method : Literal[ols;, nnls, svr], optional\n\n\n    Raises\n    ------\n    ValueError\n        Raised when solver_method is not found.\n    \"\"\"\n    super().__init__(name=f\"wls_{solver_method}\", signature_matrix=signature_matrix)\n    self._baseline_solver = SOLVER_METHODS.get(solver_method)\n    if self._baseline_solver is None:\n        raise ValueError(f\"Solver {solver_method} not found\")\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.WLS.transform","title":"<code>transform(adata, layer='relative_counts', ratio=False, max_iter=1000, tol=0.001)</code>","text":"<p>Fit the WLS model to the data and return the deconvolution values.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>Transform raw output into cell proportions, by default False</p> <code>False</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations, by default 1000</p> <code>1000</code> <code>tol</code> <code>float</code> <p>Tolerance, by default 1e-3</p> <code>0.001</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>def transform(\n    self,\n    adata: AnnData,\n    layer: str = \"relative_counts\",\n    ratio: bool = False,\n    max_iter: int = 1000,\n    tol: float = 1e-3,\n):\n    \"\"\"Fit the WLS model to the data and return the deconvolution values.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        Transform raw output into cell proportions, by default False\n    max_iter : int, optional\n        Maximum number of iterations, by default 1000\n    tol : float, optional\n        Tolerance, by default 1e-3\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_wls(adata, self._signature_matrix, layer=layer, max_iter=max_iter, tol=tol, dampened=None)\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.WNNLS","title":"<code>WNNLS</code>","text":"<p>               Bases: <code>SignatureBasedModel</code></p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>class WNNLS(SignatureBasedModel):\n    default_layer = \"relative_counts\"\n\n    def __init__(self, signature_matrix: SignatureMatrix):\n        \"\"\"Weighted Non-Negative Least Squares (WNNLS) model for deconvolution.\n\n        Parameters\n        ----------\n        signature_matrix : SignatureMatrix\n            Signature matrix used for deconv.\n\n        Raises\n        ------\n        ValueError\n            Raised when solver_method is not found.\n        \"\"\"\n        super().__init__(name=\"WNNLS\", signature_matrix=signature_matrix)\n        self._baseline_solver = SOLVER_METHODS.get(\"nnls\")\n\n    def transform(\n        self,\n        adata: AnnData,\n        layer: str = \"relative_counts\",\n        ratio: bool = False,\n        max_iter: int = 1000,\n        tol: float = 1e-3,\n    ):\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        adata : AnnData\n            Input anndata object.\n        layer : str\n            Layer of the data to use for deconvolution.\n        ratio : bool, optional\n            if True return a proportion of celltype instead raw values, by default False\n        max_iter : int, optional\n            maximum number of iterations, by default 1000\n        tol : _type_, optional\n            tolerance, by default 1e-3\n\n        Returns\n        -------\n        pd.DataFrame\n            Deconvolution values.\n        \"\"\"\n\n        adata = self.valid_input(adata, layer=layer)\n        values = solver_wls(adata, self._signature_matrix, layer=layer, max_iter=max_iter, tol=tol, dampened=None)\n\n        values = self.format_output(\n            values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n        )\n\n        return values\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.WNNLS.__init__","title":"<code>__init__(signature_matrix)</code>","text":"<p>Weighted Non-Negative Least Squares (WNNLS) model for deconvolution.</p> <p>Parameters:</p> Name Type Description Default <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix used for deconv.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised when solver_method is not found.</p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>def __init__(self, signature_matrix: SignatureMatrix):\n    \"\"\"Weighted Non-Negative Least Squares (WNNLS) model for deconvolution.\n\n    Parameters\n    ----------\n    signature_matrix : SignatureMatrix\n        Signature matrix used for deconv.\n\n    Raises\n    ------\n    ValueError\n        Raised when solver_method is not found.\n    \"\"\"\n    super().__init__(name=\"WNNLS\", signature_matrix=signature_matrix)\n    self._baseline_solver = SOLVER_METHODS.get(\"nnls\")\n</code></pre>"},{"location":"api/model/model/#pydeconv.model.WNNLS.transform","title":"<code>transform(adata, layer='relative_counts', ratio=False, max_iter=1000, tol=0.001)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Input anndata object.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> <code>'relative_counts'</code> <code>ratio</code> <code>bool</code> <p>if True return a proportion of celltype instead raw values, by default False</p> <code>False</code> <code>max_iter</code> <code>int</code> <p>maximum number of iterations, by default 1000</p> <code>1000</code> <code>tol</code> <code>_type_</code> <p>tolerance, by default 1e-3</p> <code>0.001</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Deconvolution values.</p> Source code in <code>src/pydeconv/model/wls.py</code> <pre><code>def transform(\n    self,\n    adata: AnnData,\n    layer: str = \"relative_counts\",\n    ratio: bool = False,\n    max_iter: int = 1000,\n    tol: float = 1e-3,\n):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    adata : AnnData\n        Input anndata object.\n    layer : str\n        Layer of the data to use for deconvolution.\n    ratio : bool, optional\n        if True return a proportion of celltype instead raw values, by default False\n    max_iter : int, optional\n        maximum number of iterations, by default 1000\n    tol : _type_, optional\n        tolerance, by default 1e-3\n\n    Returns\n    -------\n    pd.DataFrame\n        Deconvolution values.\n    \"\"\"\n\n    adata = self.valid_input(adata, layer=layer)\n    values = solver_wls(adata, self._signature_matrix, layer=layer, max_iter=max_iter, tol=tol, dampened=None)\n\n    values = self.format_output(\n        values, columns=self._signature_matrix.list_cell_types, index=adata.obs.index, ratio=ratio\n    )\n\n    return values\n</code></pre>"},{"location":"api/model/solver/","title":"Solver","text":""},{"location":"api/model/solver/#pydeconv.model.solver.solver_mixupvi_module","title":"<code>solver_mixupvi_module(model, signature_latent_space, adata, layer, device='cpu')</code>","text":"<p>Placeholder for MixupVI module solver.</p> Source code in <code>src/pydeconv/model/solver/nn.py</code> <pre><code>def solver_mixupvi_module(\n    model: torch.nn.Module, signature_latent_space: SignatureMatrix, adata: AnnData, layer: str, device: str = \"cpu\"\n):\n    \"\"\"Placeholder for MixupVI module solver.\"\"\"\n    x = adata.to_df(layer=layer)\n    x = torch.tensor(x.values, dtype=torch.float32).to(device)\n    model.eval()\n    latent_features = model.extract_latent(x)\n    anndata_latent = AnnData(latent_features, layers={\"latent_features\": latent_features})\n    cell_prop_ = solver_nnls(anndata_latent, signature_latent_space, layer=\"latent_features\")\n    return cell_prop_\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_nnls","title":"<code>solver_nnls(adata, signature_matrix, layer)</code>","text":"<p>Solve the linear regression using non-negative least squares.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix object.</p> required <code>layer</code> <code>str</code> <p>Layer to use for the regressions.</p> required <p>Returns:</p> Name Type Description <code>coef_</code> <code>ndarray</code> <p>Coefficients of the linear regression.</p> Source code in <code>src/pydeconv/model/solver/linear.py</code> <pre><code>def solver_nnls(adata: AnnData, signature_matrix: SignatureMatrix, layer: str):\n    \"\"\"\n    Solve the linear regression using non-negative least squares.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    signature_matrix : SignatureMatrix\n        Signature matrix object.\n    layer : str\n        Layer to use for the regressions.\n\n    Returns\n    -------\n    coef_ : np.ndarray\n        Coefficients of the linear regression.\n    \"\"\"\n    X = signature_matrix.values\n    Y = adata.to_df(layer=layer).T\n\n    coef_ = np.vstack([optimize.nnls(X, yi)[0] for yi in Y.T.values])\n    return coef_\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_nusvr","title":"<code>solver_nusvr(adata, signature_matrix, layer, norm=True, scale=False)</code>","text":"<p>Solve the linear regression using ordinary least squares</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data</p> required <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrice object</p> required <code>layer</code> <code>str</code> <p>Layer to use for the regression</p> required <code>norm</code> <code>bool</code> <p>If True, the data will be normalized to the range [-1, 1]</p> <code>True</code> <code>scale</code> <code>bool</code> <p>If True, the data will be scaled to have zero mean and unit variance.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>coef_</code> <code>ndarray</code> <p>Coefficients of the linear regression</p> Source code in <code>src/pydeconv/model/solver/svm.py</code> <pre><code>def solver_nusvr(\n    adata: AnnData,\n    signature_matrix: SignatureMatrix,\n    layer: str,\n    norm: bool = True,\n    scale=False,\n) -&gt; np.ndarray:\n    \"\"\"Solve the linear regression using ordinary least squares\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data\n    signature_matrix : SignatureMatrix\n        Signature matrice object\n    layer : str\n        Layer to use for the regression\n    norm : bool\n        If True, the data will be normalized to the range [-1, 1]\n    scale : bool\n        If True, the data will be scaled to have zero mean and unit variance.\n\n    Returns\n    -------\n\n    coef_ : np.ndarray\n        Coefficients of the linear regression\n    \"\"\"\n    model = svm.NuSVR(nu=0.5, gamma=\"auto\", kernel=\"linear\", C=1.0, cache_size=200)\n\n    X = signature_matrix.values  # row: gene, column: cell type\n    y = adata.to_df(layer=layer).T  # row: gene, column: samples\n\n    # Normalize X and y to the range [-1, 1]\n    if norm:\n        # errited from R code\n        X_max = np.max(X)\n        X_min = np.min(X)\n        upper_bounds = [np.max([X_max, y_max]) for y_max in y.max(axis=0).values]\n        lower_bounds = [np.min([X_min, y_min]) for y_min in y.min(axis=0).values]\n\n        X_norm = [\n            ((X - lower_bound) / upper_bound) * 2 - 1\n            for lower_bound, upper_bound in zip(lower_bounds, upper_bounds, strict=True)\n        ]\n        y_norm = [\n            ((y[col] - lower_bound) / upper_bound) * 2 - 1\n            for lower_bound, upper_bound, col in zip(lower_bounds, upper_bounds, y.columns, strict=True)\n        ]\n\n        if scale:\n            X_norm_scale = [\n                pd.DataFrame(StandardScaler().transform(X_norm_col), columns=X.columns, index=X.index)\n                for X_norm_col in X_norm\n            ]\n            y_norm_scale = [StandardScaler().transform(y_norm_col.to_frame()) for y_norm_col in y_norm]\n            coeffs = np.array(\n                [\n                    model.fit(X_norm_col, y_norm_col).coef_\n                    for X_norm_col, y_norm_col in zip(X_norm_scale, y_norm_scale, strict=True)\n                ]\n            ).squeeze()\n        else:\n            coeffs = np.array(\n                [model.fit(X_norm_col, y_norm_col).coef_ for X_norm_col, y_norm_col in zip(X_norm, y_norm, strict=True)]\n            ).squeeze()\n\n    else:\n        if scale:\n            X = pd.DataFrame(StandardScaler().transform(X), columns=X.columns, index=X.index)\n            y = pd.DataFrame(StandardScaler().transform(y), columns=y.columns, index=y.index)\n\n        coeffs = np.array([model.fit(X, y[col]).coef_ for col in y.columns]).squeeze()\n\n    return coeffs\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_ols","title":"<code>solver_ols(adata, signature_matrix, layer)</code>","text":"<p>Solve the linear regression using ordinary least squares.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix object.</p> required <code>layer</code> <code>str</code> <p>Layer to use for the regression.</p> required <p>Returns:</p> Name Type Description <code>coef_</code> <code>ndarray</code> <p>Coefficients of the linear regression.</p> Source code in <code>src/pydeconv/model/solver/linear.py</code> <pre><code>def solver_ols(adata: AnnData, signature_matrix: SignatureMatrix, layer: str):\n    \"\"\"\n    Solve the linear regression using ordinary least squares.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    signature_matrix : SignatureMatrix\n        Signature matrix object.\n    layer : str\n        Layer to use for the regression.\n\n    Returns\n    -------\n    coef_ : np.ndarray\n        Coefficients of the linear regression.\n    \"\"\"\n    X = signature_matrix.values\n    Y = adata.to_df(layer=layer).T\n\n    coef_, _, _, _ = linalg.lstsq(X, Y)\n    coef_ = coef_.T\n\n    return coef_\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_rlr","title":"<code>solver_rlr(adata, signature_matrix, layer)</code>","text":"<p>Solve the linear regression using robust linear regression. and huber loss function.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix object.</p> required <code>layer</code> <code>str</code> <p>Layer to use for the regression.</p> required <p>Returns:</p> Name Type Description <code>coef_</code> <code>ndarray</code> <p>Coefficients of the linear regression.</p> Source code in <code>src/pydeconv/model/solver/linear.py</code> <pre><code>def solver_rlr(adata: AnnData, signature_matrix: SignatureMatrix, layer: str):\n    \"\"\"\n    Solve the linear regression using robust linear regression. and huber loss function.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    signature_matrix : SignatureMatrix\n        Signature matrix object.\n    layer : str\n        Layer to use for the regression.\n\n    Returns\n    -------\n    coef_ : np.ndarray\n        Coefficients of the linear regression.\n    \"\"\"\n    X = signature_matrix.values\n    Y = adata.to_df(layer=layer).T\n\n    coef_ = np.vstack([sm.RLM(y, X, M=sm.robust.norms.HuberT()).fit().params for y in Y.T.values])\n    return coef_\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_svr","title":"<code>solver_svr(adata, signature_matrix, layer)</code>","text":"<p>Solve the linear regression using ordinary least squares</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data</p> required <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrice object</p> required <code>layer</code> <code>str</code> <p>Layer to use for the regression</p> required <p>Returns:</p> Name Type Description <code>coef_</code> <code>ndarray</code> <p>Coefficients of the linear regression</p> Source code in <code>src/pydeconv/model/solver/svm.py</code> <pre><code>def solver_svr(adata: AnnData, signature_matrix: SignatureMatrix, layer: str) -&gt; np.ndarray:\n    \"\"\"Solve the linear regression using ordinary least squares\n\n    Parameters\n    ----------\n\n    adata : AnnData\n        Anndata object containing the data\n    signature_matrix : SignatureMatrix\n        Signature matrice object\n    layer : str\n        Layer to use for the regression\n\n    Returns\n    -------\n\n    coef_ : np.ndarray\n        Coefficients of the linear regression\n    \"\"\"\n    # model = make_pipeline(StandardScaler(), svm.NuSVR(nu=0.5, gamma=\"auto\", kernel=\"linear\", C=1.0, cache_size=40))\n    model = svm.SVR(kernel=\"linear\")\n\n    X = signature_matrix.values  # row: gene, column: cell type\n    y = adata.to_df(layer=layer).T  # row: gene, column: samples\n\n    coeffs = np.array([model.fit(X, y[col]).coef_ for col in y.columns]).squeeze()\n\n    return coeffs\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_torch_module","title":"<code>solver_torch_module(model, adata, layer, device='cpu')</code>","text":"<p>Solve the deconvolution problem using a torch model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The model to use for deconvolution.</p> required <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>layer</code> <code>str</code> <p>Layer of the data to use for deconvolution.</p> required <code>device</code> <code>str</code> <p>Device to use for the computation, by default \"cpu\"</p> <code>'cpu'</code> Source code in <code>src/pydeconv/model/solver/nn.py</code> <pre><code>def solver_torch_module(model: torch.nn.Module, adata: AnnData, layer: str, device: str = \"cpu\"):\n    \"\"\"Solve the deconvolution problem using a torch model.\n\n    Parameters\n    ----------\n    model : torch.nn.Module\n        The model to use for deconvolution.\n    adata : AnnData\n        Anndata object containing the data.\n    layer : str\n        Layer of the data to use for deconvolution.\n    device : str, optional\n        Device to use for the computation, by default \"cpu\"\n    \"\"\"\n    model.eval()\n    x = adata.to_df(layer=layer)\n    x = torch.tensor(x.values, dtype=torch.float32).to(device)\n    model = model.to(device)\n    # can't be use with torch no grad context, because of optional adaptative step\n    cell_prop_ = model(x)\n    cell_prop_ = cell_prop_.cpu().detach().numpy()\n    return cell_prop_\n</code></pre>"},{"location":"api/model/solver/#pydeconv.model.solver.solver_wls","title":"<code>solver_wls(adata, signature_matrix, layer, max_iter=1000, tol=0.01, dampened=None, solver_func=solver_nnls, parallel=False)</code>","text":"<p>Solve the linear regression using Weighted Least Squares.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing the data.</p> required <code>signature_matrix</code> <code>SignatureMatrix</code> <p>Signature matrix object.</p> required <code>layer</code> <code>str</code> <p>Layer to use for the regression.</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of iterations, by default 1000.</p> <code>1000</code> <code>tol</code> <code>float</code> <p>Tolerance for the convergence, by default 0.01.</p> <code>0.01</code> <code>dampened</code> <code>Union[list, Literal['auto'], None]</code> <p>Dampening constant for the weights. If None, no dampening is applied. If \"auto\", the dampening constant is calculated automatically, by default None.</p> <code>None</code> <code>solver_func</code> <code>Callable</code> <p>Function to solve the linear regression, by default solver_nnls.</p> <code>solver_nnls</code> <code>parallel</code> <code>bool</code> <p>Whether to run the solver in parallel, by default False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>coef_</code> <code>ndarray</code> <p>Coefficients of the linear regression.</p> Source code in <code>src/pydeconv/model/solver/linear.py</code> <pre><code>def solver_wls(\n    adata: AnnData,\n    signature_matrix: SignatureMatrix,\n    layer: str,\n    max_iter: int = 1000,\n    tol: float = 0.01,\n    dampened: Union[list, Literal[\"auto\"], None] = None,\n    solver_func=solver_nnls,\n    parallel: bool = False,\n):\n    \"\"\"\n    Solve the linear regression using Weighted Least Squares.\n\n    Parameters\n    ----------\n    adata : AnnData\n        Anndata object containing the data.\n    signature_matrix : SignatureMatrix\n        Signature matrix object.\n    layer : str\n        Layer to use for the regression.\n    max_iter : int, optional\n        Maximum number of iterations, by default 1000.\n    tol : float, optional\n        Tolerance for the convergence, by default 0.01.\n    dampened : Union[list, Literal[\"auto\"], None], optional\n        Dampening constant for the weights. If None, no dampening is applied.\n        If \"auto\", the dampening constant is calculated automatically, by default None.\n    solver_func : Callable, optional\n        Function to solve the linear regression, by default solver_nnls.\n    parallel : bool, optional\n        Whether to run the solver in parallel, by default False.\n\n    Returns\n    -------\n    coef_ : np.ndarray\n        Coefficients of the linear regression.\n    \"\"\"\n\n    X = signature_matrix.values.copy()  # row: gene, column: cell type\n    Y = adata.to_df(layer=layer).T.copy()  # row: genes, column: samples\n\n    coef_init = solver_func(adata, signature_matrix, layer).T  # row: celltypes, column: samples\n\n    # Define dampening constants\n    if dampened == \"auto\":\n        dampened = [find_dampening_constant(X, y, coef) for (_, y), coef in zip(Y.items(), coef_init.T, strict=True)]\n    elif isinstance(dampened, float):\n        dampened = np.array([dampened] * Y.shape[1])\n    elif dampened is None:\n        dampened = [None] * Y.shape[1]\n    if len(dampened) != Y.shape[1]:\n        raise ValueError(\"Dampening constant must be a float or a list of floats with the same length as the samples\")\n\n    # Solve the weighted linear regression\n    if parallel:\n        coef_ = solver_wls_parallel(X, Y, coef_init, max_iter=max_iter, tol=tol, dampened=dampened)\n    else:\n        coef_ = [\n            solver_wls_per_patient(X, y, c, d, max_iter, tol)\n            for (_, y), c, d in tqdm(\n                zip(Y.items(), coef_init.T, dampened, strict=True), total=len(Y), position=3, leave=False\n            )\n        ]\n    coef_ = np.array(coef_)\n\n    return coef_  # output: row: samples, column: cell types\n</code></pre>"},{"location":"api/model/nn/registry/","title":"Registry module","text":""},{"location":"api/model/nn/registry/#pydeconv.model.nn.registry.mixupvi_module_cti","title":"<code>mixupvi_module_cti(granularity, device='cpu')</code>","text":"<p>Factory function to create a MixupVIModule with predefined parameters.</p> <p>Parameters:</p> Name Type Description Default <code>granularity</code> <code>Literal['1st_granularity', '2nd_granularity']</code> <p>The granularity level for the MixupVIModule.</p> required <code>device</code> <code>str</code> <p>The device to load the model on, by default \"cpu\".</p> <code>'cpu'</code> <p>Returns:</p> Type Description <code>Tuple[Module, dict]</code> <p>A tuple containing the MixupVIModule instance and its parameters.</p> Source code in <code>src/pydeconv/model/nn/registry.py</code> <pre><code>def mixupvi_module_cti(\n    granularity: Literal[\"1st_granularity\", \"2nd_granularity\"], device=\"cpu\"\n) -&gt; Tuple[nn.Module, dict]:\n    \"\"\"Factory function to create a MixupVIModule with predefined parameters.\n    Parameters\n    ----------\n    granularity : Literal[\"1st_granularity\", \"2nd_granularity\"]\n        The granularity level for the MixupVIModule.\n    device : str, optional\n        The device to load the model on, by default \"cpu\".\n    Returns\n    -------\n    Tuple[nn.Module, dict]\n        A tuple containing the MixupVIModule instance and its parameters.\n    \"\"\"\n    path_parameters = download_file_to_cache(\n        repo_url=REPO_URL,\n        origin=ORIGIN,\n        relative_path=f\"mixupvi/cti_dirichlet_{granularity}/mixupvi_params.json\",\n    )\n    with open(path_parameters) as f:\n        params = json.load(f)\n\n    model = MixupVIModule(\n        input_dim=params[\"input\"][\"input_dim\"],\n        latent_dim=params[\"output\"][\"latent_dim\"],\n    )\n\n    path_model = download_file_to_cache(\n        repo_url=REPO_URL,\n        origin=ORIGIN,\n        relative_path=f\"mixupvi/cti_dirichlet_{granularity}/mixupvi_weights.pt\",\n    )\n\n    model_dict = torch.load(\n        path_model,\n        map_location=device,\n        weights_only=False,\n    )\n\n    model.model.load_state_dict(model_dict[\"model_state_dict\"])\n    return model, params\n</code></pre>"},{"location":"api/model/nn/registry/#pydeconv.model.nn.registry.scaden_module_cti","title":"<code>scaden_module_cti(granularity, device='cpu')</code>","text":"<p>Factory function to create a ScadenModule with predefined parameters.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>The version of the ScadenModule to create.</p> required <p>Returns:</p> Type Description <code>Module</code> <p>An instance of ScadenModule with the specified version.</p> Source code in <code>src/pydeconv/model/nn/registry.py</code> <pre><code>def scaden_module_cti(\n    granularity: Literal[\"1st_granularity\", \"2nd_granularity\"], device=\"cpu\"\n) -&gt; Tuple[nn.Module, dict]:\n    \"\"\"Factory function to create a ScadenModule with predefined parameters.\n\n    Parameters\n    ----------\n    version :str\n        The version of the ScadenModule to create.\n\n    Returns\n    ----------\n    nn.Module\n        An instance of ScadenModule with the specified version.\n    \"\"\"\n    path_parameters = download_file_to_cache(\n        repo_url=REPO_URL,\n        origin=ORIGIN,\n        relative_path=f\"scaden/cti_dirichlet_{granularity}/scaden_params.json\",\n    )\n    with open(path_parameters) as f:\n        params = json.load(f)\n\n    model = ScadenModule(\n        input_dim=params[\"input\"][\"input_dim\"],\n        output_dim=params[\"output\"][\"output_dim\"],\n        model_params_dict=DEFAULT_SCADEN_ARCHITECTURES,\n    )\n    for shape in [\"256\", \"512\", \"1024\"]:\n        path_model = download_file_to_cache(\n            repo_url=REPO_URL,\n            origin=ORIGIN,\n            relative_path=f\"scaden/cti_dirichlet_{granularity}/scaden_weights_{shape}.pth\",\n        )\n        state_dict = torch.load(\n            path_model,\n            map_location=device,\n            weights_only=True,\n        )\n        for key in list(state_dict.keys()):\n            state_dict[key.replace(\"model.\", \"mlp.\")] = state_dict.pop(key)\n\n        getattr(model, f\"model_{shape}\").load_state_dict(state_dict)\n    return model, params\n</code></pre>"},{"location":"api/model/nn/registry/#pydeconv.model.nn.registry.tape_module_cti","title":"<code>tape_module_cti(granularity, adaptative, device='cpu')</code>","text":"<p>Factory function to create a ScadenModule with predefined parameters.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>The version of the ScadenModule to create.</p> required <p>Returns:</p> Type Description <code>nn.Module: An instance of ScadenModule with the specified version.</code> Source code in <code>src/pydeconv/model/nn/registry.py</code> <pre><code>def tape_module_cti(\n    granularity: Literal[\"1st_granularity\", \"2nd_granularity\"], adaptative, device=\"cpu\"\n) -&gt; Tuple[nn.Module, dict]:\n    \"\"\"Factory function to create a ScadenModule with predefined parameters.\n\n    Parameters\n    ----------\n    version :str\n        The version of the ScadenModule to create.\n\n    Returns\n    ----------\n    nn.Module: An instance of ScadenModule with the specified version.\n    \"\"\"\n    path_parameters = download_file_to_cache(\n        repo_url=REPO_URL,\n        origin=ORIGIN,\n        relative_path=f\"tape/cti_dirichlet_{granularity}/tape_params.json\",\n    )\n    with open(path_parameters) as f:\n        params = json.load(f)\n\n    model = TapeModule(\n        input_dim=params[\"input\"][\"input_dim\"], output_dim=params[\"output\"][\"output_dim\"], adaptative=adaptative\n    )\n\n    path_model = download_file_to_cache(\n        repo_url=REPO_URL,\n        origin=ORIGIN,\n        relative_path=f\"tape/cti_dirichlet_{granularity}/tape_weights.pth\",\n    )\n    state_dict = torch.load(\n        path_model,\n        map_location=device,\n        weights_only=True,\n    )\n    model.load_state_dict(state_dict)\n    return model, params\n</code></pre>"},{"location":"api/model/nn/scaden/","title":"Scaden","text":""},{"location":"api/model/nn/scaden/#pydeconv.model.nn.scaden.ScadenModule","title":"<code>ScadenModule</code>","text":"<p>               Bases: <code>Module</code></p> <p>ScadenModule is a simple implementation of the Scaden model from the original implementation. paper: https://www.nature.com/articles/s41467-022-34550-9</p> <p>This module is a combination of three ScadenBaseModule with different parameters.</p> <p>Attributes:</p> Name Type Description <code>model_256</code> <code>ScadenBaseModule</code> <p>ScadenBaseModule with 256 hidden units.</p> <code>model_512</code> <code>ScadenBaseModule</code> <p>ScadenBaseModule with 512 hidden units.</p> <code>model_1024</code> <code>ScadenBaseModule</code> <p>ScadenBaseModule with 1024 hidden</p> <p>Methods:</p> Name Description <code>forward</code> <p>Forward pass of the model.</p> Source code in <code>src/pydeconv/model/nn/scaden.py</code> <pre><code>@requires_torch\nclass ScadenModule(nn.Module):\n    \"\"\"ScadenModule is a simple implementation of the Scaden model from the original implementation.\n    paper: https://www.nature.com/articles/s41467-022-34550-9\n\n    This module is a combination of three ScadenBaseModule with different parameters.\n\n    Attributes\n    ----------\n    model_256 : ScadenBaseModule\n        ScadenBaseModule with 256 hidden units.\n    model_512 : ScadenBaseModule\n        ScadenBaseModule with 512 hidden units.\n    model_1024 : ScadenBaseModule\n        ScadenBaseModule with 1024 hidden\n\n    Methods\n    -------\n    forward(x)\n        Forward pass of the model.\n    \"\"\"\n\n    def __init__(self, input_dim: int, output_dim: int, model_params_dict: dict):\n        \"\"\"ScadenModule is a simple implementation of the Scaden model from the original implementation.\n\n        Parameters\n        ----------\n        input_dim : int\n            Input dimension.\n        output_dim : int\n            Output dimension.\n        model_params_dict : dict\n            model parameters.\n        \"\"\"\n        super().__init__()\n\n        # Initialize the models with different parameters\n        self.model_256 = _ScadenBaseModule(input_dim=input_dim, output_dim=output_dim, **model_params_dict[\"model_256\"])\n        self.model_512 = _ScadenBaseModule(input_dim=input_dim, output_dim=output_dim, **model_params_dict[\"model_512\"])\n        self.model_1024 = _ScadenBaseModule(\n            input_dim=input_dim, output_dim=output_dim, **model_params_dict[\"model_1024\"]\n        )\n\n    def forward(self, x):\n        \"\"\"Forward pass of the model.\n\n        Parameters\n        ----------\n        x : torch.Tensor\n            Input tensor.\n\n        Returns\n        -------\n        torch.Tensor\n            Output\n        \"\"\"\n        # Get predictions from each model\n        output_1 = self.model_256(x)\n        output_2 = self.model_512(x)\n        output_3 = self.model_1024(x)\n\n        # Combine the outputs (e.g., averaging)\n        output = (output_1 + output_2 + output_3) / 3\n        return output\n</code></pre>"},{"location":"api/model/nn/scaden/#pydeconv.model.nn.scaden.ScadenModule.__init__","title":"<code>__init__(input_dim, output_dim, model_params_dict)</code>","text":"<p>ScadenModule is a simple implementation of the Scaden model from the original implementation.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>Input dimension.</p> required <code>output_dim</code> <code>int</code> <p>Output dimension.</p> required <code>model_params_dict</code> <code>dict</code> <p>model parameters.</p> required Source code in <code>src/pydeconv/model/nn/scaden.py</code> <pre><code>def __init__(self, input_dim: int, output_dim: int, model_params_dict: dict):\n    \"\"\"ScadenModule is a simple implementation of the Scaden model from the original implementation.\n\n    Parameters\n    ----------\n    input_dim : int\n        Input dimension.\n    output_dim : int\n        Output dimension.\n    model_params_dict : dict\n        model parameters.\n    \"\"\"\n    super().__init__()\n\n    # Initialize the models with different parameters\n    self.model_256 = _ScadenBaseModule(input_dim=input_dim, output_dim=output_dim, **model_params_dict[\"model_256\"])\n    self.model_512 = _ScadenBaseModule(input_dim=input_dim, output_dim=output_dim, **model_params_dict[\"model_512\"])\n    self.model_1024 = _ScadenBaseModule(\n        input_dim=input_dim, output_dim=output_dim, **model_params_dict[\"model_1024\"]\n    )\n</code></pre>"},{"location":"api/model/nn/scaden/#pydeconv.model.nn.scaden.ScadenModule.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of the model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input tensor.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Output</p> Source code in <code>src/pydeconv/model/nn/scaden.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass of the model.\n\n    Parameters\n    ----------\n    x : torch.Tensor\n        Input tensor.\n\n    Returns\n    -------\n    torch.Tensor\n        Output\n    \"\"\"\n    # Get predictions from each model\n    output_1 = self.model_256(x)\n    output_2 = self.model_512(x)\n    output_3 = self.model_1024(x)\n\n    # Combine the outputs (e.g., averaging)\n    output = (output_1 + output_2 + output_3) / 3\n    return output\n</code></pre>"},{"location":"api/model/nn/tape/","title":"TAPE","text":""},{"location":"api/model/nn/tape/#pydeconv.model.nn.tape.TapeModule","title":"<code>TapeModule</code>","text":"<p>               Bases: <code>Module</code></p> <p>TapeModule is a simple implementation of the TAPE model from the original implementation.</p> <p>paper: https://www.nature.com/articles/s41467-022-34550-9</p> Source code in <code>src/pydeconv/model/nn/tape.py</code> <pre><code>@requires_torch\nclass TapeModule(nn.Module):\n    \"\"\"TapeModule is a simple implementation of the TAPE model from the original implementation.\n\n    paper: https://www.nature.com/articles/s41467-022-34550-9\n    \"\"\"\n\n    def __init__(self, input_dim: int, output_dim: int, adaptative: bool = False):\n        \"\"\"TapeModule is a simple implementation of the TAPE model from the original implementation.\n\n        Parameters\n        ----------\n        input_dim : int\n            Input dimension.\n        output_dim : int\n            Output dimension.\n        adaptative : bool, optional\n            Adaptative step for predicting the model, by default True.\n        \"\"\"\n        super().__init__()\n        self.adaptative_step: bool = adaptative\n\n        self.encoder = nn.Sequential(\n            nn.Dropout(),\n            nn.Linear(input_dim, 512),\n            nn.CELU(),\n            nn.Dropout(),\n            nn.Linear(512, 256),\n            nn.CELU(),\n            nn.Dropout(),\n            nn.Linear(256, 128),\n            nn.CELU(),\n            nn.Dropout(),\n            nn.Linear(128, 64),\n            nn.CELU(),\n            nn.Linear(64, output_dim),\n        )\n\n        # not used in the predit method\n        self.decoder = nn.Sequential(\n            nn.Linear(output_dim, 64, bias=False),\n            nn.Linear(64, 128, bias=False),\n            nn.Linear(128, 256, bias=False),\n            nn.Linear(256, 512, bias=False),\n            nn.Linear(512, input_dim, bias=False),\n            nn.ReLU(),\n        )\n        self.activation = nn.ReLU()\n\n    @property\n    def signature_matrix(self) -&gt; torch.Tensor:\n        \"\"\"Pseudo property to get the signature matrix from the model.\n\n        Returns\n        -------\n        torch.Tensor\n            Signature matrix from the model.\n        \"\"\"\n        sm = torch.mm(self.decoder[0].weight.T, self.decoder[1].weight.T)\n        sm = torch.mm(sm, self.decoder[2].weight.T)\n        sm = torch.mm(sm, self.decoder[3].weight.T)\n        sm = torch.mm(sm, self.decoder[4].weight.T)\n        sm = F.relu(sm)\n        return sm\n\n    def forward(self, x: torch.Tensor) -&gt; Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]:\n        \"\"\"Forward pass of the model.\n\n        Parameters\n        ----------\n        x : torch.Tensor\n            Input tensor.\n\n        Returns\n        -------\n        Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]\n            Output tensor or tuple of output tensor and reconstructed\n            tensor.\n        \"\"\"\n        z = self.encoder(x)\n        if self.training:\n            x_reconstruct = torch.mm(z, self.signature_matrix)\n            output = (z, x_reconstruct)\n        else:\n            if self.adaptative_step:\n                model_adapted = adaptative_step(self, x, device=x.device)\n                model_adapted.eval()\n                output = model_adapted(x)\n            else:\n                output = self.activation(z)\n        return output\n</code></pre>"},{"location":"api/model/nn/tape/#pydeconv.model.nn.tape.TapeModule.signature_matrix","title":"<code>signature_matrix: torch.Tensor</code>  <code>property</code>","text":"<p>Pseudo property to get the signature matrix from the model.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>Signature matrix from the model.</p>"},{"location":"api/model/nn/tape/#pydeconv.model.nn.tape.TapeModule.__init__","title":"<code>__init__(input_dim, output_dim, adaptative=False)</code>","text":"<p>TapeModule is a simple implementation of the TAPE model from the original implementation.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>Input dimension.</p> required <code>output_dim</code> <code>int</code> <p>Output dimension.</p> required <code>adaptative</code> <code>bool</code> <p>Adaptative step for predicting the model, by default True.</p> <code>False</code> Source code in <code>src/pydeconv/model/nn/tape.py</code> <pre><code>def __init__(self, input_dim: int, output_dim: int, adaptative: bool = False):\n    \"\"\"TapeModule is a simple implementation of the TAPE model from the original implementation.\n\n    Parameters\n    ----------\n    input_dim : int\n        Input dimension.\n    output_dim : int\n        Output dimension.\n    adaptative : bool, optional\n        Adaptative step for predicting the model, by default True.\n    \"\"\"\n    super().__init__()\n    self.adaptative_step: bool = adaptative\n\n    self.encoder = nn.Sequential(\n        nn.Dropout(),\n        nn.Linear(input_dim, 512),\n        nn.CELU(),\n        nn.Dropout(),\n        nn.Linear(512, 256),\n        nn.CELU(),\n        nn.Dropout(),\n        nn.Linear(256, 128),\n        nn.CELU(),\n        nn.Dropout(),\n        nn.Linear(128, 64),\n        nn.CELU(),\n        nn.Linear(64, output_dim),\n    )\n\n    # not used in the predit method\n    self.decoder = nn.Sequential(\n        nn.Linear(output_dim, 64, bias=False),\n        nn.Linear(64, 128, bias=False),\n        nn.Linear(128, 256, bias=False),\n        nn.Linear(256, 512, bias=False),\n        nn.Linear(512, input_dim, bias=False),\n        nn.ReLU(),\n    )\n    self.activation = nn.ReLU()\n</code></pre>"},{"location":"api/model/nn/tape/#pydeconv.model.nn.tape.TapeModule.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of the model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input tensor.</p> required <p>Returns:</p> Type Description <code>Union[Tensor, Tuple[Tensor, Tensor]]</code> <p>Output tensor or tuple of output tensor and reconstructed tensor.</p> Source code in <code>src/pydeconv/model/nn/tape.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]:\n    \"\"\"Forward pass of the model.\n\n    Parameters\n    ----------\n    x : torch.Tensor\n        Input tensor.\n\n    Returns\n    -------\n    Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]\n        Output tensor or tuple of output tensor and reconstructed\n        tensor.\n    \"\"\"\n    z = self.encoder(x)\n    if self.training:\n        x_reconstruct = torch.mm(z, self.signature_matrix)\n        output = (z, x_reconstruct)\n    else:\n        if self.adaptative_step:\n            model_adapted = adaptative_step(self, x, device=x.device)\n            model_adapted.eval()\n            output = model_adapted(x)\n        else:\n            output = self.activation(z)\n    return output\n</code></pre>"},{"location":"api/model/nn/tape/#pydeconv.model.nn.tape.adaptative_step","title":"<code>adaptative_step(model, data, n_steps=10, n_iter=5, device='cpu', lr=0.0001)</code>","text":"<p>Adaptive stage for training the model from the original implementation. https://github.com/poseidonchan/TAPE/blob/8ffb2f4600e1cbc689c6b1b1f428e1ddac773c6e/TAPE/train.py#L42</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>TapeModule</code> <p>The model to adapt.</p> required <code>data</code> <code>Tensor</code> <p>Input data.</p> required <code>n_steps</code> <code>int</code> <p>Number of steps to perform, by default 10</p> <code>10</code> <code>n_iter</code> <code>int</code> <p>Number of iterations to perform, by default 5</p> <code>5</code> <code>device</code> <code>Union[str, device]</code> <p>Device to use for the computation, by default \"cpu\"</p> <code>'cpu'</code> <code>lr</code> <code>float</code> <p>Learning rate, by default 1e-4</p> <code>0.0001</code> Source code in <code>src/pydeconv/model/nn/tape.py</code> <pre><code>def adaptative_step(\n    model: TapeModule,\n    data: torch.Tensor,\n    n_steps: int = 10,\n    n_iter: int = 5,\n    device: Union[str, torch.device] = \"cpu\",\n    lr: float = 1e-4,\n) -&gt; nn.Module:\n    \"\"\"Adaptive stage for training the model from the original implementation.\n    https://github.com/poseidonchan/TAPE/blob/8ffb2f4600e1cbc689c6b1b1f428e1ddac773c6e/TAPE/train.py#L42\n\n    Parameters\n    ----------\n    model : TapeModule\n        The model to adapt.\n    data : torch.Tensor\n        Input data.\n    n_steps : int, optional\n        Number of steps to perform, by default 10\n    n_iter : int, optional\n        Number of iterations to perform, by default 5\n    device : Union[str, torch.device], optional\n        Device to use for the computation, by default \"cpu\"\n    lr : float, optional\n        Learning rate, by default 1e-4\n    \"\"\"\n    data = data.to(device)\n    # Because the model is trained in place, we need to copy the model to not modify the original model weights\n    # if we perform multiple predicts\n    model_copy = copy.deepcopy(model)\n    model_copy.eval()\n    model_copy.adaptative_step = False\n\n    opt_encoder = torch.optim.Adam(model_copy.encoder.parameters(), lr=lr)\n    opt_decoder = torch.optim.Adam(model_copy.decoder.parameters(), lr=lr)\n\n    origin_pred = model_copy(data)\n    origin_sigmatrix = model_copy.signature_matrix.detach()\n    origin_pred = origin_pred.detach()\n\n    for _ in range(n_iter):\n        model_copy.train()\n        for _ in range(n_steps):\n            seed_all(seed=0)\n            opt_decoder.zero_grad()\n            _, x_recon = model_copy(data)\n            batch_loss = F.l1_loss(x_recon, data) + F.l1_loss(model_copy.signature_matrix, origin_sigmatrix)\n            batch_loss.backward()\n            opt_decoder.step()\n\n        for _ in range(n_steps):\n            seed_all(seed=0)\n            opt_encoder.zero_grad()\n            pred, x_recon = model_copy(data)\n            batch_loss = F.l1_loss(origin_pred, pred) + F.l1_loss(x_recon, data)\n            batch_loss.backward()\n            opt_encoder.step()\n\n    return model_copy\n</code></pre>"},{"location":"api/signature_matrix/registry/","title":"Registry signatures","text":""},{"location":"api/signature_matrix/registry/#pydeconv.signature_matrix.registry.sig_matrix_cti_granularity_1","title":"<code>sig_matrix_cti_granularity_1()</code>","text":"<p>Load the cross tissue immune signature matrix (1st granualrity level).</p> Source code in <code>src/pydeconv/signature_matrix/registry.py</code> <pre><code>def sig_matrix_cti_granularity_1():\n    \"\"\"Load the cross tissue immune signature matrix (1st granualrity level).\"\"\"\n    path = download_file_to_cache(\n        repo_url=REPO_URL, origin=ORIGIN, relative_path=\"sig_matrix_Cross_Tissue_Immune_granularity_1.csv\"\n    )\n    return SignatureMatrix.load(path, index_col=0)\n</code></pre>"},{"location":"api/signature_matrix/registry/#pydeconv.signature_matrix.registry.sig_matrix_cti_granularity_2","title":"<code>sig_matrix_cti_granularity_2()</code>","text":"<p>Load the cross tissue immune signature matrix (2nd granualrity level).</p> Source code in <code>src/pydeconv/signature_matrix/registry.py</code> <pre><code>def sig_matrix_cti_granularity_2():\n    \"\"\"Load the cross tissue immune signature matrix (2nd granualrity level).\"\"\"\n    path = download_file_to_cache(\n        repo_url=REPO_URL, origin=ORIGIN, relative_path=\"sig_matrix_Cross_Tissue_Immune_granularity_2.csv\"\n    )\n    return SignatureMatrix.load(path, index_col=0)\n</code></pre>"},{"location":"api/signature_matrix/registry/#pydeconv.signature_matrix.registry.sig_matrix_laughney_lung_cancer","title":"<code>sig_matrix_laughney_lung_cancer()</code>","text":"<p>Load the Laugney lung cancer signature matrix.</p> Source code in <code>src/pydeconv/signature_matrix/registry.py</code> <pre><code>def sig_matrix_laughney_lung_cancer():\n    \"\"\"Load the Laugney lung cancer signature matrix.\"\"\"\n    path = download_file_to_cache(repo_url=REPO_URL, origin=ORIGIN, relative_path=\"sig_matrix_laughney_lung_cancer.csv\")\n    return SignatureMatrix.load(path, index_col=0)\n</code></pre>"},{"location":"api/signature_matrix/signature_matrix/","title":"Signature matrix","text":""},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix","title":"<code>SignatureMatrix</code>","text":"<p>Signature matrix object.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>DataFrame</code> <p>Signature matrix.</p> <code>list_genes</code> <code>list</code> <p>List of genes.</p> <code>list_cell_types</code> <code>list</code> <p>List of cell types.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load a signature matrix from a file.</p> Source code in <code>src/pydeconv/signature_matrix/signature_matrix.py</code> <pre><code>class SignatureMatrix:\n    \"\"\"Signature matrix object.\n\n    Attributes\n    ----------\n    values : pd.DataFrame\n        Signature matrix.\n    list_genes : list\n        List of genes.\n    list_cell_types : list\n        List of cell types.\n\n    Methods\n    -------\n    load(path, **kwargs)\n        Load a signature matrix from a file.\n    \"\"\"\n\n    def __init__(self, df: pd.DataFrame):\n        \"\"\"Signature matrix object.\n\n        Parameters\n        ----------\n        df : pd.DataFrame\n            Signature matrix, rows are genes, columns are cell types.\n        \"\"\"\n        self._df = df\n\n    @classmethod\n    def load(clf, path: str, **kwargs):\n        \"\"\"Load a signature matrix from a file. Only support csv file for now.\"\"\"\n        df = load_signature_matrix(Path(path), **kwargs)\n        return clf(df)\n\n    @property\n    def values(self):\n        \"\"\"Signature matrix.\"\"\"\n        return self._df\n\n    @property\n    def list_genes(self):\n        \"\"\"List of genes.\"\"\"\n        return self._df.index.to_list()\n\n    @property\n    def list_cell_types(self):\n        \"\"\"List of cell types.\"\"\"\n        return self._df.columns.to_list()\n\n    def update_gene_list(self, new_gene_list):\n        \"\"\"Update the gene list.\"\"\"\n        self._df = self._df.loc[new_gene_list]\n</code></pre>"},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix.list_cell_types","title":"<code>list_cell_types</code>  <code>property</code>","text":"<p>List of cell types.</p>"},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix.list_genes","title":"<code>list_genes</code>  <code>property</code>","text":"<p>List of genes.</p>"},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix.values","title":"<code>values</code>  <code>property</code>","text":"<p>Signature matrix.</p>"},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix.__init__","title":"<code>__init__(df)</code>","text":"<p>Signature matrix object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Signature matrix, rows are genes, columns are cell types.</p> required Source code in <code>src/pydeconv/signature_matrix/signature_matrix.py</code> <pre><code>def __init__(self, df: pd.DataFrame):\n    \"\"\"Signature matrix object.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Signature matrix, rows are genes, columns are cell types.\n    \"\"\"\n    self._df = df\n</code></pre>"},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix.load","title":"<code>load(clf, path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a signature matrix from a file. Only support csv file for now.</p> Source code in <code>src/pydeconv/signature_matrix/signature_matrix.py</code> <pre><code>@classmethod\ndef load(clf, path: str, **kwargs):\n    \"\"\"Load a signature matrix from a file. Only support csv file for now.\"\"\"\n    df = load_signature_matrix(Path(path), **kwargs)\n    return clf(df)\n</code></pre>"},{"location":"api/signature_matrix/signature_matrix/#pydeconv.signature_matrix.SignatureMatrix.update_gene_list","title":"<code>update_gene_list(new_gene_list)</code>","text":"<p>Update the gene list.</p> Source code in <code>src/pydeconv/signature_matrix/signature_matrix.py</code> <pre><code>def update_gene_list(self, new_gene_list):\n    \"\"\"Update the gene list.\"\"\"\n    self._df = self._df.loc[new_gene_list]\n</code></pre>"},{"location":"model_registry/models/","title":"Model registry","text":""},{"location":"model_registry/models/#models","title":"Models","text":""},{"location":"model_registry/models/#scaden","title":"Scaden","text":"<p>Paper: Deep learning\u2013based cell composition analysis from tissue expression profiles</p> <pre><code>from pydeconv.model import Scaden\nmodel = Scaden()\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/models/#registered-models","title":"Registered models","text":"<ul> <li> <p><code>cti_dirichlet_2nd_granularity</code></p> <p>... details dataset and model ...</p> Output Celltypes <p><code>B</code>, <code>CD4T</code>, <code>CD8T</code>, <code>DC</code>, <code>Mast</code>, <code>Mono</code>, <code>NK</code>, <code>Plasma</code>, <code>Tregs</code></p> </li> </ul>"},{"location":"model_registry/models/#tape","title":"TAPE","text":"<p>Paper: Deep autoencoder for interpretable tissue-adaptive deconvolution and cell-type-specific gene analysis</p> <pre><code>from pydeconv.model import Tape\nmodel = Tape()\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/models/#registered-models_1","title":"Registered models","text":"<ul> <li> <p><code>cti_dirichlet_2nd_granularity</code></p> <p>... details dataset and model ...</p> Output Celltypes <p><code>B</code>, <code>CD4T</code>, <code>CD8T</code>, <code>DC</code>, <code>Mast</code>, <code>Mono</code>, <code>NK</code>, <code>Plasma</code>, <code>Tregs</code></p> </li> </ul>"},{"location":"model_registry/models/#signature-based-models","title":"Signature based models","text":""},{"location":"model_registry/models/#ols","title":"OLS","text":"<p>Paper:</p> <pre><code>from pydeconv.model import OLS\nmodel = OLS(signature_matrix)\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/models/#rlr","title":"RLR","text":"<p>Paper:</p> <pre><code>from pydeconv.model import RLR\nmodel = RLR(signature_matrix)\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/models/#nnls","title":"NNLS","text":"<p>Paper: Deconvolution of blood microarray data identifies cellular activation patterns in systemic lupus erythematosus</p> <pre><code>from pydeconv.model import NNLS\nmodel = NNLS(signature_matrix)\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/models/#dwls","title":"DWLS","text":"<p>Paper: Accurate estimation of cell-type composition from gene expression data</p> <pre><code>from pydeconv.model import DWLS\nmodel = DWLS(signature_matrix)\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/models/#wnnls-music","title":"WNNLS (MuSiC)","text":"<p>Paper: Bulk tissue cell type deconvolution with multi-subject single-cell expression reference</p> <pre><code>from pydeconv.model import WNNLS\nmodel = WNNLS(signature_matrix)\nmodel.transform(adata, layer=\"tpm\", ratio=True)\n</code></pre>"},{"location":"model_registry/signatures/","title":"Signature registry","text":"<p>The signature matrix is a matrix that contains the expression of genes for each cell type. It is used to predict the cell type composition of a sample. PyDeconv provides a registry of signature matrices that can be used to predict the cell type composition of a sample.</p> <p>The signature matrices are stored in CSV files and can be loaded using the <code>pydeconv.signature_matrix.registry</code> module.</p> <p>Commercialy available signature matrices</p> <p>The following signature matrices are commercially available. You can use them without any restrictions.</p> <p>Research only signature matrices</p> <p>The following signature matrices are for research purposes only.</p> <p>Private only signature matrices</p> <p>The following signature matrices are private and can only be used by</p>"},{"location":"model_registry/signatures/#laugney-lung-cancer","title":"Laugney Lung Cancer","text":"<ul> <li>indication: <code>lung</code></li> <li>dataset used:</li> <li>n patients:</li> <li>n cells:</li> <li>extraction comments:</li> </ul> <pre><code>from pydeconv.signature_matrix.registry import sig_matrix_laughney_lung_cancer\n</code></pre> Output Celltypes <p><code>TNK</code>, <code>B</code>, <code>MonoMacro</code>, <code>Mast</code>, <code>Endothelial</code>, <code>Malignant</code>, <code>Stroma</code>, <code>DC</code>, <code>Epithelial</code></p>"},{"location":"model_registry/signatures/#cross-tissue-immune-main-cp","title":"Cross tissue immune main CP","text":"<ul> <li>indication:</li> <li>dataset used:</li> <li>n patients:</li> <li>n cells:</li> <li>extraction comments:</li> </ul> <pre><code>from pydeconv.signature_matrix.registry import sig_matrix_cti_granularity_1\n</code></pre> Output Celltypes <p><code>TNK</code>, <code>B</code>, <code>MonoMacro</code>, <code>DC</code>, <code>Mast</code></p>"},{"location":"model_registry/signatures/#cross-tissue-immune-main-2nd-granularity","title":"Cross tissue immune main 2nd granularity","text":"<ul> <li>indication:</li> <li>dataset used:</li> <li>n patients:</li> <li>n cells:</li> <li>extraction comments:</li> </ul> <pre><code>from pydeconv.signature_matrix.registry import sig_matrix_cti_granularity_2\n</code></pre> Output Celltypes <p><code>CD4T</code>, <code>CD8T</code>, <code>B</code>, <code>Plasma</code>, <code>DC</code>, <code>NK</code>, <code>Mono</code>, <code>Mast</code>, <code>Tregs</code></p>"},{"location":"model_registry/signatures/#cross-tissue-immune-main-3rd-granularity","title":"Cross tissue immune main 3rd granularity","text":"<ul> <li>indication:</li> <li>dataset used:</li> <li>n patients:</li> <li>n cells:</li> <li>extraction comments:</li> </ul>"}]}